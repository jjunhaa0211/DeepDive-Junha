# Static Dispatch, Dynamic Dispatch?
## 컴파일과 런타임

- 컴파일: 우리가 작성한 코드가 어셈블리어, 즉 기계가 이해할 수 있는 0과 1의 언어로 변환되는 과정을 말합니다.
- 런타임: 위에서 컴파일을 거친 코드가, 사용자에 의해 사용되어지는 순간을 말합니다.

## Dispatch

> 오버라이드 된 메서드가 존재할 때, 어떤 메서드를 호출할 것인지를 결정하여, 그것을 실행하는 메커니즘
> 

swift에서 메서드 호출 방식으로는 static Dispatch와 Dynamic Dispatch 두 방식이 있습니다.

### Static Dispatch

> 컴파일 타임에 어떤 메소드를 호출할지를 정하는 방법
> 

특징

- 컴파일러가 컴파일 시점에 호출해야 할, 메서드의 실제 위치를
- 컴파일 시점에서 정하기 때문에 성능상 이점을 가지게 됩니다.(속도가 빠릅니다.)
- 주로 값 타입에서 사용하게 되는데, 그말은 struct 또는 enum에서 사용됩니다.
- 애초에 struct와 enum은 상속이 불가능 하기 때문에 당연히 오버라이딩도 없습니다.
    - 모든 구조체에서 사용합니다.
- 클래스에서 상속을 못하게 되므로 객체 지향 프로그래밍의 다형성을 구현하지 못하죠

### Dynamic Dispatch

> 런타임 시점에 호출될 메서드 또는 속성을 결정합니다.
> 

특징

- 클래스마다 함수 포인터들의 배열인 vTable(Virtual Methon Table)이라는 것을 유지하며, 하위 클래스에서 상속을 하고 해당 함수를 불러왔다면 vTable을 참조하여 실제 호출할 함수를 정하게 됩니다.
    - 쉽게 생각해서 각 클래스가 vTable을 생성하여 이를 객체의 인스턴스에 연결합니다. 객체가 메서드를 호출할 때마다 해당 vTable에서는 부모 메서드 인지 자식 메서드 인지 위치를 찾은 후 메서드를 실행하게 되므로 속도가 상대적으로 떨어지게 됩니다.
- 상속받았고, 해당 함수가 상속받은 클래스에 존재한다면, 해당 함수가 호출될때 그게 어디에 존재하는 함수인지를 확인할 때 이과정 런타임이 발생합니다.
- 정적 디스패치와는 반대로 런타임 시점에 호출할 메서드를 알아내기 때문에, 상속 관계에서 오버라이드한 자식 클래스의 메서드를 호출가능해집니다.
    - 하지만 어떤 메서드가 호출될지 정확히 모르므로 성능 및 속도가 떨어집니다.

런타임 발생

- 성능이 저하된다 → 테이블을 읽고 → 해당 메소드로 이동해야하는 과정을 거치기 때문에
- 이과정에서 오버헤드가 발생합니다.

정리

- 정리하면 프로토콜에서도, 이와 같은 런타임 시점에서 메소드 호출을 확인하기 때문에 dynamic dispatch를 사용하게 된니다. 때문에 클래스와 프로토콜은 dynamic dispatch를 사용합니다.

## 성능 개선 방법

class나 protocol에 의한 메소드들은 dynamic dispatch를 사용하게 되고, 이 때문에 오버헤드가 발생하여 앱 성능이 떨어지게 된다.

### 방지하는 방법

- final 키워드를 사용하기 따라서 final 키워드를 사용하여 상속이 불가능하도록 하게 되면 자연스럽게 static dispatch를 사용하게 되어, 이는 앱 성능 개선으로 이어집니다.
- dynamic dispatch를 사용하게 되는 이유는 우리가 상속을 통한 오버라이드로 인하여, 어떠한 메소드가 실행되는지 런타임에 체크를 해줘야 하는 문제를 해결하기 위한 것이다.
- private 키워드를 사용하기 따라서  파일내에 해당 요소에 대한 오버라이드가 없는 경우 컴파일러가 이를 자동으로 static dispatch로 바꿔 줄 수 있다.
- private 키워드를 붙여서 선언하게 되면 해당 요소는 한 파일 내에서만 참조된다.
- WMO(Whole Module Optimization)을 사용하기 swift는 기본적으로 모듈을 이루는 파일들을 개별적으로 컴파일 하기 때문에 다른 파일에서 오버라이딩이 일어났는지 알 수 없습니다. 하지만 WMO를 활성화하면 모듈 전체가 하나의 덩어리로 취급되어 컴파일 되기 떄문에 모듈 내의 internal 선언은 모듈 바깥에 드러나지 않아 오버라이딩이 불가능 하다는 것이 보장되기 때문에 static dispatch를 사용하게 됩니다.
- WMO를 사용하게 되면 internal 선언만으로 final을 추론해낼 수 있습니다. (물론 모듈 내에 오버라이딩이 없는 경우)

## @objc dynamic

### 사용 이유

- Swift에서는 기본적으로 정적 디스패치를 사용하지만, Objective-C의 동적 디스패치 기능을 사용하기 위해 사용합니다.
- Objective-C와 상호 운영성을 유지하게 도와줍니다.

보통의 경우에는 `@objc dynamic var` 를 사용하게 되면 런타임 시 동적으로 동작이 결정이 되므로 프로퍼티가 변경되었을 때, KVO(Key-Value-Observing)를 통해 관찰이 가능해집니다.

런타임에서 프로퍼티의 값이 변경될 때마다, 시스템이 자동적으로 프로퍼티 관찰자(`@objc dynamic var`)를 호출하고 값을 업데이트할 수 있습니다.

하지만 동적으로 처리되므로 컴파일러가 해당 프로퍼티를 최적화할 수 없다고 합니다.
성능상의 이슈가 발생하기 때문에 남용하면 안됩니다.
